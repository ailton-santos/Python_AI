# -*- coding: utf-8 -*-
"""Projeto Final - Programação com IA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JhyvB66eXkBN2aEOjv_CK4hxEFTgPc1o
"""

import pandas as pd
import numpy as np
from sklearn.metrics import accuracy_score

# --- Re-gerar df_clientes (necessário para garantir a existência do DataFrame) ---
# Esta parte do código é uma cópia da geração dos dados simulados.
np.random.seed(42) # Para reprodutibilidade

num_clientes = 1000

data = {
    'ID_Cliente': range(1, num_clientes + 1),
    'Idade': np.random.randint(18, 70, num_clientes),
    'Tempo_Servico_Meses': np.random.randint(1, 60, num_clientes),
    'Tipo_Plano': np.random.choice(['Básico', 'Intermediário', 'Premium'], num_clientes, p=[0.4, 0.4, 0.2]),
    'Valor_Mensal': np.random.uniform(30, 150, num_clientes).round(2),
    'Uso_Dados_GB': np.random.uniform(5, 100, num_clientes).round(2),
    'Ligacoes_Minutos': np.random.uniform(50, 1000, num_clientes).round(2),
    'Suporte_Tecnico': np.random.choice(['Sim', 'Não'], num_clientes, p=[0.3, 0.7]),
    'Problemas_Rede': np.random.choice(['Sim', 'Não'], num_clientes, p=[0.2, 0.8]),
    'Churn': np.random.choice([0, 1], num_clientes, p=[0.85, 0.15])
}

df_clientes = pd.DataFrame(data)

df_clientes.loc[df_clientes['Tempo_Servico_Meses'] < 12, 'Churn'] = np.random.choice([0, 1], sum(df_clientes['Tempo_Servico_Meses'] < 12), p=[0.7, 0.3])
df_clientes.loc[df_clientes['Problemas_Rede'] == 'Sim', 'Churn'] = np.random.choice([0, 1], sum(df_clientes['Problemas_Rede'] == 'Sim'), p=[0.6, 0.4])
df_clientes.loc[df_clientes['Suporte_Tecnico'] == 'Sim', 'Churn'] = np.random.choice([0, 1], sum(df_clientes['Suporte_Tecnico'] == 'Sim'), p=[0.7, 0.3])


# A regra é: Se o cliente reportou 'Problemas_Rede' como 'Sim' OU usou 'Suporte_Tecnico' como 'Sim',
# prevemos que ele tem maior probabilidade de churn (1). Caso contrário, prevemos que não (0).

def prever_churn_simples(row):
    """
    Função que implementa a regra de negócio para prever churn.
    Retorna 1 (churn) se o cliente reportou problemas de rede OU usou suporte técnico.
    Retorna 0 (não churn) caso contrário.
    """
    if row['Problemas_Rede'] == 'Sim' or row['Suporte_Tecnico'] == 'Sim':
        return 1
    else:
        return 0

# Aplicar a função a cada linha do DataFrame para gerar a nova coluna de previsão
df_clientes['Churn_Previsto'] = df_clientes.apply(prever_churn_simples, axis=1)

print("--- Previsão do Modelo  ---")
print("As primeiras 10 linhas do DataFrame com a previsão do modelo :")
print(df_clientes[['ID_Cliente', 'Problemas_Rede', 'Suporte_Tecnico', 'Churn', 'Churn_Previsto']].head(10))



y_true = df_clientes['Churn'] # Valores reais de churn
y_pred_simple = df_clientes['Churn_Previsto'] # Valores previstos pelo modelo simples

accuracy_simple = accuracy_score(y_true, y_pred_simple)


print(f"Acurácia do Modelo : {accuracy_simple:.2f}")


print("\n--- Observações Finais sobre o Modelo  ---")
print(f"O modelo simples previu {y_pred_simple.sum()} clientes com churn de um total de {num_clientes} clientes.")
print(f"A taxa de churn real na base de dados simulada é de {df_clientes['Churn'].mean()*100:.2f}%.")

print("\n--- Análise do Projeto   ---")
print('''Na análise de padrões para clientes que cancelam, observamos que:

Tempo de Serviço:
Clientes que evadiram tinham um tempo de serviço médio ligeiramente menor.

Suporte Técnico:
Uma proporção maior de clientes que evadiram utilizou o suporte técnico.

Problemas de Rede:
Uma incidência maior de problemas de rede foi associada a clientes que evadiram.

E, na análise de importância das variáveis, utilizando os coeficientes da Regressão Logística, identificamos que:

A ausência de problemas de rede e a não utilização do suporte técnico são os fatores mais fortes na redução da probabilidade de churn.
A presença de problemas de rede e a necessidade de suporte técnico são os maiores impulsionadores da evasão.
Clientes com planos Premium e Básico tenderam a ter menor probabilidade de churn em comparação com o Intermediário.''')

